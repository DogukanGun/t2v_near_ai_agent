name: Semantic Versioning and Release

on:
  workflow_dispatch:
    inputs:
      release_type:
        description: 'Release type (major, minor, patch)'
        required: true
        default: 'patch'
        type: choice
        options:
          - major
          - minor
          - patch
      branch:
        description: 'Branch to release from'
        required: true
        default: 'main'

jobs:
  release:
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.event.inputs.branch }}

      - name: Get latest tag
        id: get_latest_tag
        run: |
          git fetch --tags
          LATEST_TAG=$(git tag --sort=-v:refname | grep '^v[0-9]*\.[0-9]*\.[0-9]*$' | head -n 1 || echo "v0.0.0")
          echo "LATEST_TAG=${LATEST_TAG}" >> $GITHUB_ENV
          echo "Latest tag: ${LATEST_TAG}"
          
          # Extract version components
          if [[ "${LATEST_TAG}" =~ ^v([0-9]+)\.([0-9]+)\.([0-9]+)$ ]]; then
            MAJOR="${BASH_REMATCH[1]}"
            MINOR="${BASH_REMATCH[2]}"
            PATCH="${BASH_REMATCH[3]}"
            echo "MAJOR=${MAJOR}" >> $GITHUB_ENV
            echo "MINOR=${MINOR}" >> $GITHUB_ENV
            echo "PATCH=${PATCH}" >> $GITHUB_ENV
          else
            echo "MAJOR=0" >> $GITHUB_ENV
            echo "MINOR=0" >> $GITHUB_ENV
            echo "PATCH=0" >> $GITHUB_ENV
          fi

      - name: Determine new version
        id: new_version
        run: |
          if [ "${{ github.event.inputs.release_type }}" = "major" ]; then
            NEW_MAJOR=$((MAJOR + 1))
            NEW_VERSION="v${NEW_MAJOR}.0.0"
          elif [ "${{ github.event.inputs.release_type }}" = "minor" ]; then
            NEW_MINOR=$((MINOR + 1))
            NEW_VERSION="v${MAJOR}.${NEW_MINOR}.0"
          else
            NEW_PATCH=$((PATCH + 1))
            NEW_VERSION="v${MAJOR}.${MINOR}.${NEW_PATCH}"
          fi
          
          echo "NEW_VERSION=${NEW_VERSION}" >> $GITHUB_ENV
          echo "New version: ${NEW_VERSION}"

      - name: Generate release notes
        id: release_notes
        run: |
          PREV_TAG="${LATEST_TAG}"
          if [[ "${PREV_TAG}" == "v0.0.0" ]]; then
            PREV_TAG=$(git rev-list --max-parents=0 HEAD)
          fi
          
          echo "Generating release notes from ${PREV_TAG} to HEAD"
          
          # Generate release notes from PR titles
          NOTES=$(git log "${PREV_TAG}..HEAD" --pretty=format:"* %s (%h)" --merges | grep -v "Merge pull request")
          
          if [[ -z "${NOTES}" ]]; then
            # Fallback to commit messages if no PRs are found
            NOTES=$(git log "${PREV_TAG}..HEAD" --pretty=format:"* %s (%h)" --no-merges)
          fi
          
          echo "RELEASE_NOTES<<EOF" >> $GITHUB_ENV
          echo "${NOTES}" >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV

      - name: Create tag and release
        id: create_release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Create and push tag
          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"
          git tag -a ${NEW_VERSION} -m "Release ${NEW_VERSION}"
          git push origin ${NEW_VERSION}
          
          # Create GitHub release
          gh release create ${NEW_VERSION} \
            --title "Release ${NEW_VERSION}" \
            --notes "${RELEASE_NOTES}" \
            --target ${{ github.event.inputs.branch }} 